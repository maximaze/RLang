print(“Hello World”)
# 패키지 로드
abc <- 1
abc
library(stringr)
abc
# 변수 abc에 초기값 1을 할당
abc <- 1
# 숫자로 변수를 시작하면 안된다.
# Error: unexpected symbol in "1abc"
# 1abc <- 2
_abc <- "abc"
# 숫자로 변수를 시작하면 안된다.
# Error: unexpected symbol in "1abc"
# 1abc <- 2
# _abc <- "abc"
.abc <- 123
abc
.abc
#오류는 아니지만 권조하지 않음
.point <- 123
.point
pi <- 3.14
pi
# 기존의 자료형에 새로운 자료형의 값을 지정하면 자료혀이 변경 됨
abc <- "abc"
abc
goods.code <- 'G001'
goods.name <- "냉장고"
goods.price <- 850000
goods.desc <- "최고사양의 '동급최강' 냉장고"
goods.code
goods.name
goods.price
goods.desc
goods.option <- '옵션: "350l"'
goods.option
# 메트릭스 생성
m <- matrix(c(1:5))
m
# 열우선 2*5열 행렬
m10 <- matrix(c(1:10), nrow=2)
m10
# 열우선으로 데이터가 지정 2*5열 행렬
# 경고: ata length
m11 <- matrix(c(1:11), nrow=2)
m11
View(m11)
m11 <- matrix(c(2:11), nrow=2)
m11 <- matrix(c(2:11), nrow=2)
m11
m11 <- matrix(c(2:11), nrow=2)
m11
m11 <- matrix(c(2:11), nrow=2)
m11
m11 <- matrix(c(1:11), nrow=2)
m11
m11 <- matrix(c(2:11), nrow=2)
m11
m11 <- matrix(c(2:12), nrow=2)
m11
# 행 우선으로 데이터가 지정 2*6열 12개 행렬
# 행우선: byrow = T
m12 <- matrix(c(1:12), nrow=2, byrow=T)
m12
m[1,1]; m[1,2]; m[1,3]; m[1,4]; m[1,5];
m[1,1] # 1행 1열
m[2,2] # 2행 1열
m[1,1] # 1행 1열
m[3,2] # 3행 1열
m[3,2] # 3행 1열
m[2,2] # 2행 1열
m[2,1] # 2행 1열
m[3,1] # 3행 1열
m[4,1] # 4행 1열
m[5,1] # 5행 1열
m[1,1]; m[1,2]; m[1,3]; m[1,4]; m[1,5];
# Error in m[1, 2]: subscript out of bounds
# m[1,2]
ncol(m)
m[1,1]; m[1,2]; m[1,3]; m[1,4]; m[1,5]
# 1행 5열
m <- matrix(c(1:5), nrow=1)
m[1,1]; m[1,2]; m[1,3]; m[1,4]; m[1,5]
ncol(m) #5
nrow(m)
length(m)
length(10)
length(m10)
ncol(m10)
nrow(m10)
# apply() 함수
# apply(X, MARGIN, FUN, ...)
# X : 행렬객체
# MARGIN : 1(행단위), 2(열단위)
# FUN : 함수
x <- matrix(c(1:9), nrow=3, ncol=3)
x
# 행단위 max 값
apply(x, 1, max)
apply(x, 1, min) # 7 8 9
apply(x, 2, mean)
# 행우선
result <- apply(x,1, fun)
x * c(1,2,3)
# 행우선
result <- apply(x,1, fun)
result
# 행우선 사용자 함수 적용
# 벡터 데이터 연산할 때 열 단위로 결과 출력
result <- apply(x,1, fun)
# 사용자 정의 함수
fun <- function(x) {
x * c(1,2,3)
}
# 행우선 사용자 함수 적용
# 벡터 데이터 연산할 때 열 단위로 결과 출력
result <- apply(x,1, fun)
result
View(m)
View(m)
View(m)
# rep() 함수
# rep(시작값:종료값, 반복값)
# 1부터 3까지 연속된 숫자를 3번 반복(전체를 3번 반복)
rep(1:3,3) # 1 2 3 1 2 3 1 2 3
# rep(시작값:종료값, each=반복값)
# 1부터 3까지의 각각의 숫자를 3번 반복
rep(1:3, each=3) # 1 1 1 2 2 2 3 3 3
# union() 합집합
# 중복되는 데이터는 하나만 서택
x <- c(1,3,5,7)
y <- c(3,5)
union(x,y)  # 1 3 5 7
# 백터값에 칼럼명 지정
names(age) <- c("흥", "이", "강")
# 백터값에 칼럼명 지정
names(age) <- c("흥", "이", "강")
# 벡터 객체의 값에 칼럼명을 지정
age <- c(30,40,50)
age
# 백터값에 칼럼명 지정
names(age) <- c("흥", "이", "강")
age
names(age) # "홍" "이" "강"
names(age) <- NULL
names(age)
age
# 데이터셋
install.packages("RSADBE")  # 패키지 설치
library(RSADBE)             # 패키지 로딩
# 데이터셋 가져오기
data("Severity_Counts")
# 데이터셋 구조보기
str(Severity_Counts)
# 데이터셋 데이터 보기
Severity_Counts
# 데이터셋 가져오기
data("Severity_Counts")
# 데이터셋 데이터 보기
Severity_Counts
# 1행 5열
m <- matrix(c(1:5), nrow=1)
m
m
length(10) # 10
# 열우선으로 데이터가 지정 2*5열 행렬
m10 <- matrix(c(1:10), nrow=2)
m10
length(10) # 10
ncol(m10) # 5
nrow(m10) # 2
length(m10) # 10
# 열 우선으로 데이터가 지정 2*6열 12개 행렬
# 부족한 1개의 마지막 요소는 첫 번째 데이터부터 채운다.
# 경고 : data length [11] is not a sub-multiple or multiple of the number of rows [2]
# 열우선으로 데이터가 지정 2*5열 행렬
m11 <- matrix(c(1:11), nrow=2)
m11
# 백터
vec <- c(1:12)
vec
# 배열
arr <- array(vec, c(3,2,2))
arr
# 조회
arr[,,1] # 1면조회
arr[,,2] # 2면조회
arr
arr[,,2] # 2면조회
arr[1,1,1] # 1행 1열 1면
arr[3,2,2] # 3행 2열 2면
no <- c(1,2,3)
name <-("홍","이","김")
pay <- c(100,200,300)
name <-c("홍","이","김")
vemp <- data.frame(No = no, Name=name, Pay=pay)
vemp
# 하나라도 행의 값이 작은 것이 있으면 가장 작은 칼럼의 값으로
# 데이터프레임이 생성된다.
no1 <- c(1,2,3)
name1 <-c("홍","이","김")
pay1 <- c(100,200,300)
hemp <- date.frame(번호 = no1, 이름 = name1, 급여 = pay1)
hemp
hemp <- date.frame(번호 = no1, 이름=name1, 급여=pay1)
hemp <- data.frame(번호 = no1, 이름=name1, 급여=pay1)
hemp
no1
# 하나라도 행의 값이 작은 것이 있으면 가장 작은 칼럼의 값으로
# 데이터프레임이 생성된다.
no1 <- c(1,3,5,7)
no1
name1 <-c("홍","이","김","박")
hemp <- data.frame(번호 = no1, 이름=name1, 급여=pay1)
hemp
hemp
# 하나라도 행의 값이 작은 것이 있으면 가장 작은 칼럼의 값으로
# 데이터프레임이 생성된다.
no1 <- c(1,3,5,7)
no1
hemp
# 하나라도 행의 값이 작은 것이 있으면 가장 작은 칼럼의 값으로
# 데이터프레임이 생성된다.
no1 <- c(1,3,5,7)
no1
name1 <-c("홍","이","김","박")
pay1 <- c(100,200,300)
hemp <- data.frame(번호 = no1, 이름=name1, 급여=pay1)
vemp2 <- data.frame(번호 = no1, 이름=name1, 급여=pay1)
# 하나라도 행의 값이 작은 것이 있으면 오류
# 데이터프레임이 생성된다.
vemp2 <- data.frame(번호 = c(1,3,5,7), 이름=name, 급여=pay)
vemp2
no <- c(1,2,3)
name <-c("홍","이","김")
pay <- c(100,200,300)
vemp <- data.frame(No = no, Name=name, Pay=pay)
vemp
# 하나라도 행의 값이 작은 것이 있으면 오류
# 데이터프레임이 생성된다.
vemp2 <- data.frame(번호 = c(1,3,5,7), 이름=name, 급여=pay)
# matrix를 이용한 데이터프레임 객체 생성
# 3행 3열 : 행우선
m <- matrix(
c(1,"hong",150,
2,"lee",250
3,"kim",325),3)
m
# matrix를 이용한 데이터프레임 객체 생성
# 3행 3열 : 행우선
m <- matrix(
c(1,"hong",150,
2,"lee",250
3,"kim",325),3, by=T)
# matrix를 이용한 데이터프레임 객체 생성
# 3행 3열 : 행우선
m <- matrix(c(1,"hong",150, 2,"lee",250, 3,"kim",325),3, by=T)
m
memp <- data.frame(m)
memp
m2 <- matrix(
c(1,"hong",150,
2,"lee",250,
3,"kim",325), nrow=3, byrow=TRUE)
memp2 <- data.frame(m2)
memp2
# 작업영역 확인
getwd()
setwd("D:/RLang/workspace")
View(m2)
# 텍스트 파일 읽어 오기
# 제목있음 : header=1
# 칼럼구분 : sep="" 공백으로 구분
txtemp <-  read.table("emp.txt", header=1, sep=1)
# 텍스트 파일 읽어 오기
# 제목있음 : header=1
# 칼럼구분 : sep="" 공백으로 구분
txtemp <- read.table("emp.txt", header=1, sep=1)
# 작업영역 확인
getwd()
# 텍스트 파일 읽어 오기
# 제목있음 : header=1
# 칼럼구분 : sep="" 공백으로 구분
txtemp <- read.table("emp.txt", header=1, sep=1)
# 텍스트 파일 읽어 오기
# 제목있음 : header=1
# 칼럼구분 : sep="" 공백으로 구분
txtemp <- read.table("emp.txt", header=1, sep="")
txtemp
str(txtemp)   # 데이터프레임의 구조
ncol(txtemp)  # 칼럼갯수: 제목제외
nrow(txtemp)  # 행의 갯수
names(txtemp) # 제목
# 칼럼명으로 칼럼의 값을 참조하기
# 객체$칼럼명
txtemp$사번
txtemp$이름
txtemp$급여
# csv 파일을 이용한 데이터프레임 객체 생서
csvtemp <- read.csv("emp.csv", header=T)
csvtemp
# csv에 칼럼 헤더가 없는 경우
csv2 = read.csv("emp2.csv", header=F, col.names=c("사번", "이름", "급여"))
csv2
csv2$급여
csv2$이름
csv2$사번
# 파일에 칼럼이 없는데 header 옵션을 지정하지 않으면 첫 번째 칼럼이 헤더로 인식
# 기본값 : header=T
csv2 = read.csv("emp2.csv")
csv2
# 파일에 헤더 없으면 header=F 옵션을 지정해야 한다.
# 칼럼을 지정하지 않으면, 자동으로 임의의 칼럼명을 지정해줌
csv2 = read.csv("emp2.csv", header=F)
csv2
csv2 = read.csv("emp2.csv", header=F, col.names=c("사번", "이름", "급여"))
csv2
csv2$사번
csv2$이름
csv2$급여
# 논리합 : |
df
xyor <- subset(df, x >= 5 | y <=3 )
xyor
# student 데이터프레임 만들기
sid <- c('A', 'B', 'C', 'D')
score <- c(70,80,90,100)
subject <- c('컴퓨터', '국어', '소프트웨어', '유아')
student <- data.frame(sid, score, subject)
student
str(student)
# 논리부정 : !
xynot <- subset(df, !(x>=5 | y<=3))
xynot
# 머지(merge)
# 두 개 이상의 데이터프레임 병합
height <- data.frame(id=c(1,2), h=c(180,175))
height
weight <- data.frame(id=c(1,2), w=c(80,75))
weight
user <- merge(height, weight, by.x='id', by.y='id')
user
# key를 생략한 list
# 인덱스가 키가 된다.
list <- list("lee", "이순신", 95)
list
mode(list)  #list
class(list)
# 키가 없는 리스트 참조
list[[1]]
# list > vector
unlist <- unlist(list)
unlist
unlist[3]
# 백터
unlist[1]
# 키가 없는 리스트 참조
list[[1]]
member <- list(name=c("홍", "유"),
age=c(34,21),
address=c("한양","충남"),
gender=c("남","여"))
member
member <- list(
title="고객정보",
name=c("홍", "유"),
age=c(34,21),
address=c("한양","충남"),
gender=c("남","여"))
member
# 키 참조
member$title
# 리스트 객체의 자료 처리함수
# lapply()
a <- list(c(1:5))
a[[1]]
a[[1]]
b <- list(c(6:10))
b
b[[1]]
lapply(c(a,b), max)
lapply(a,max)
lapply(b,max)
abmax <- c(laaply(a,max), lapply(b,max))
abmax
abmax <- c(lapply(a,max), lapply(b,max))
abmax
# 다차원 리스트 객체 생성
multi_list <- list(
c1 = list(1,2,3),
c2 = list(10,20,30),
c3 = list(100,200,300)
)
multi_list
multi_list$c1
multi_list$c1[[1]]
multi_list$c1[[3]]
multi_list
# 다차원 리스트를 열단위로 바인딩
# matrix 객체 생성
mlist <- do.call(cbind, multi_list)
class(mlist)
mlist
# 패키지 설치 및 로딩
install.packages("stringr")
library(stringr)
# 문자열에서 해당하는 패턴이 일치하는 처음 위치의 문자를 리턴
str_extract("홍길동34이순신45유관순25", "[1-9]{2}")
# 매치되는 모든 숫자
str_extract_all("홍길동34이순신45유관순25", "[1-9]{2}") # 34
# 매치되는 모든 숫자
str_extract_all("홍길동34이순신123유관순456", "[1-9]{2}") # 34, 45, 25
str_extract("홍길동34이순신123유관순456", "[1-9]{4}") # 4567
str_extract("홍길동34이순신123유관순456", "[1-9]{4}") # 4567
str_extract("홍길동34이순신123유관순456", "[1-9]{3}") # 123
str_extract("홍길동34이순신123유관순456", "[1-9]{4}") # 4567
str_extract("홍길동34이순신123유관순4567", "[1-9]{4}") # 4567
str_extract("홍길동304이순신10203유관순4050607", "[1-9]{2}") # NA
# 0부터 9까지의 숫자중 연속해서 나오는 두 자리 숫자에 해당
str_extract("홍길동304이순신10203유관순4050607", "[0-9]{2}") # 30
str_extract_all("홍길동304이순신10203유관순4050607", "[0-9]{2}") # 30
str <- "홍길동34이순신123유관순456"
str_extract(str, "유관순")
str_extract(str, "전우치")
str_extract(str, "[가-힣]{3}")
str_extract(str, "[가-힣]{3}")
str_extract_all(str, "[가-힣]{3}")
len <- str_length(str)
# 문자열 길이
str <- "홍길동34이순신123유관순456권율."
len <- str_length(str)
len
# 반복 횟수
str <- "abcdef123ghijkl343434time999end"
str_extract_all(str, "[a-z]{5,}")
str_extract_all(str, "[a-z]{5,8}") # 영문자가 5번 이상 반복되는 패턴
# 반복 횟수
str <- "abcdef123ghijkl343abcdefg43time999end"
str_extract_all(str, "[a-z]{5,8}") # 영문자가 5번이상 8번이하 반복되는 패턴
# 반복 횟수
str <- "abcdef123ghijkl343abcdefg43times999end"
str_extract_all(str, "[a-z]{5,8}") # 영문자가 5번이상 8번이하 반복되는 패턴
# 부분 문자열 만들기
str <- "ABCDEFGHIJKLNMOPQRSTUVWXYZ"
len <- str_length(str)
sb <- str_sub(str, 1, len) # 문자열 전체
sb1 <- str_sub(str,5,10)
sb1
lowerstr <- str_to_lower(str)
lowerstr
upperstr <- str_to_upper(str)
upperstr
# 문자열 교체
# str_replace(문자열, 교체대상문자열, 교체할문자열)
repstr <- str_replace(str, "XYZ", "END")
repstr
# 문자열 결합
# 원본 문자열 뒤에 새로운 문자열을 결합
# str_c(문자열, 결합할문자열)
constr <- str_c(str,"END.")
constr
# 문자열 분리
# str_split(문자열, 분리할구분자)
str <- "010-1234-5678"
tel <- str_split(str,"-")
tel
class(tel)
tel[[1]]
tel[[2]]
tel[[3]]
tel[[1]][2]
tel[[1]][3]
untel <-unlist(tel)
untel
class(untel)
untel[3]
untel[2]
untel[1]
# 문자열을 분할 -> list -> vector
untel <- unlist(str_split(str,"-"))
untel
# 문자열 합치기
str_vec <- c("홍길동","이순신","강감찬")
str_vec
str_join <-paste(str_vec, collapse=",")
str_join
#
paste("Welcome to", "Korea")
#
str_c("Welcome to", "Korea")
paste(untel, collapse=".")
